name: Publish

on:
  workflow_dispatch:
  push:
    branches:
      - main

permissions:
  contents: write
  id-token: write
  packages: write
  pull-requests: read

env:
  ZB_TOKEN: ${{ secrets.ZB_TOKEN }}
  NPM_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  READ_TOKEN: ${{ secrets.READ_TOKEN }}
  WRITE_TOKEN: ${{ secrets.WRITE_TOKEN }}
  DISPATCH_TOKEN: ${{ secrets.DISPATCH_TOKEN }}
  SLACK_DEVOPS_NOTIFICATIONS: ${{ secrets.SLACK_DEVOPS_NOTIFICATIONS }}
  SLACK_RELEASES_WEBHOOK: ${{ secrets.SLACK_RELEASES_WEBHOOK }}

jobs:
  publish:
    name: Publish
    runs-on: [self-hosted, Linux]

    steps:
      - name: Acquire cache v4
        uses: actions/cache@v4
        with:
          path: .git
          key: repo-git-folder

      - name: Check out code v4
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup node v4
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'
      
      - name: configure git user
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com

      - name: Install nx
        run: |
          npm install -g nx@22.4.2
        env:
          NPM_TOKEN: ${{ env.NPM_TOKEN }}
          READ_TOKEN: ${{ env.READ_TOKEN }}
          ZB_TOKEN: ${{ env.ZB_TOKEN }}

      - name: Install dependencies
        run: |
          npm ci
        env:
          NPM_TOKEN: ${{ env.NPM_TOKEN }}
          READ_TOKEN: ${{ env.READ_TOKEN }}
          ZB_TOKEN: ${{ env.ZB_TOKEN }}

      - name: Determine base ref and detect changes
        id: detect_changes
        run: |
          # Get the last publish tag for base reference
          LAST_PUBLISH_TAG=$(git describe --tags --abbrev=0 --match="*" 2>/dev/null || echo "")
          if [ -z "$LAST_PUBLISH_TAG" ]; then
            echo "No publish tag found, using origin/main~1 as base"
            BASE_REF="origin/main~1"
          else
            echo "Using last publish tag as base: $LAST_PUBLISH_TAG"
            BASE_REF="$LAST_PUBLISH_TAG"
          fi
          echo "BASE_REF=$BASE_REF" >> $GITHUB_OUTPUT

          # Detect packages with actual source changes
          # Using --hoisted mode since devops uses hoisted dependencies
          # Note: Using direct path since this runs in the devops repo itself
          CHANGED_DIRS=$(./tools/scripts/detect-changes.sh "$BASE_REF" --hoisted)

          if [ -z "$CHANGED_DIRS" ]; then
            echo "No packages changed (lock-file-only changes detected), skipping build/publish"
            echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
          else
            echo "Changed packages:"
            echo "$CHANGED_DIRS"
            # Convert newlines to spaces for safe use in for loops
            CHANGED_DIRS_INLINE=$(echo "$CHANGED_DIRS" | tr '\n' ' ')
            echo "CHANGED_DIRS=$CHANGED_DIRS_INLINE" >> $GITHUB_OUTPUT
            echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
          fi
        env:
          NPM_TOKEN: ${{ env.READ_TOKEN }}
          ZB_TOKEN: ${{ env.ZB_TOKEN }}

      - name: Build changed packages
        if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
        run: |
          for pkg in ${{ steps.detect_changes.outputs.CHANGED_DIRS }}; do
            echo "Building $pkg"
            if [ -f "$pkg/package.json" ] && grep -q '"build"' "$pkg/package.json"; then
              (cd "$pkg" && npm run build)
            fi
          done
        env:
          NPM_TOKEN: ${{ env.NPM_TOKEN }}
          READ_TOKEN: ${{ env.READ_TOKEN }}
          ZB_TOKEN: ${{ env.ZB_TOKEN }}

      - name: Version changed packages, then commit
        if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
        run: |
          for pkg in ${{ steps.detect_changes.outputs.CHANGED_DIRS }}; do
            if [ -f "$pkg/package.json" ]; then
              echo "Bumping version for $pkg"
              cd "$pkg"
              npm version patch --no-git-tag-version
              cd - > /dev/null
            fi
          done
          git add -A "*/package.json" "package.json" 2>/dev/null || true
          git commit -m "chore: bump versions [skip ci]" || echo "No version changes to commit"
          git push
        env:
          NPM_TOKEN: ${{ env.READ_TOKEN }}
          ZB_TOKEN: ${{ env.ZB_TOKEN }}

      - name: Save package.json state before prepublish - main
        if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
        run: |
          echo "Saving package.json files before prepublish modifications..."
          mkdir -p /tmp/package-json-backup
          find . -name "package.json" -not -path "*/node_modules/*" -exec cp --parents {} /tmp/package-json-backup/ \;

      - name: Prepare standalone packages
        if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
        run: |
          for pkg in ${{ steps.detect_changes.outputs.CHANGED_DIRS }}; do
            if [ -f "$pkg/package.json" ] && grep -q '"nx:prepublish"' "$pkg/package.json"; then
              echo "Running prepublish for $pkg"
              (cd "$pkg" && npm run nx:prepublish)
            fi
          done
        env:
          NPM_TOKEN: ${{ env.READ_TOKEN }}
          ZB_TOKEN: ${{ env.ZB_TOKEN }}

      - name: Publish packages
        if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
        run: |
          for pkg in ${{ steps.detect_changes.outputs.CHANGED_DIRS }}; do
            if [ -f "$pkg/package.json" ] && grep -q '"nx:publish"' "$pkg/package.json"; then
              echo "Publishing $pkg"
              (cd "$pkg" && npm run nx:publish)
            fi
          done
        env:
          ZB_TOKEN: ${{ env.ZB_TOKEN }}
          NPM_TOKEN: ${{ env.GITHUB_TOKEN }}
          NODE_AUTH_TOKEN: ${{ env.GITHUB_TOKEN }}

      - name: Restore package.json state after publish
        if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
        run: |
          echo "Restoring package.json files to pre-prepublish state..."
          cp -r /tmp/package-json-backup/./* .

      - name: Create and push publish tag
        if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
        run: |
          # Create a tag for each published package to mark successful publish
          for pkg in ${{ steps.detect_changes.outputs.CHANGED_DIRS }}; do
            if [ -f "$pkg/package.json" ]; then
              PKG_NAME=$(jq -r '.name' "$pkg/package.json")
              PKG_VERSION=$(jq -r '.version' "$pkg/package.json")
              TAG_NAME="${PKG_NAME}@${PKG_VERSION}"
              echo "Creating tag: $TAG_NAME"
              git tag -f "$TAG_NAME" -m "Published $PKG_NAME version $PKG_VERSION"
              git push origin "$TAG_NAME" --force
            fi
          done

      - name: Slack Notification on failure
        uses: slackapi/slack-github-action@v2.0.0
        if: failure()
        with:
          webhook: ${{ env.SLACK_DEVOPS_NOTIFICATIONS }}
          webhook-type: incoming-webhook
          payload: |
            {
              "text": ":fire: ${{ inputs.image-name }} (${{ steps.platform.outputs.tag }}) image build failed",
              "attachments": [
                {
                  "color": "danger",
                  "text": "<https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow run>"
                }
              ]
            }

      - name: Release Announcement
        uses: zerobias-org/devops/actions/release-announcement@main
