name: 'Pull Request Hoisted'
description: 'Handle the Pull Request testing flow for zerobias-org or zerobias-com hoisted mono repo'

inputs:
  pre-built:
    description: 'Set to true if build was already run externally, skips build step'
    required: false
    default: 'false'
  pg-host:
    description: 'PostgreSQL host (only needed with pre-built: true)'
    required: false
    default: ''
  pg-port:
    description: 'PostgreSQL port (only needed with pre-built: true)'
    required: false
    default: ''
  pg-user:
    description: 'PostgreSQL user (only needed with pre-built: true)'
    required: false
    default: ''
  pg-password:
    description: 'PostgreSQL password (only needed with pre-built: true)'
    required: false
    default: ''
  pg-database:
    description: 'PostgreSQL database (only needed with pre-built: true)'
    required: false
    default: ''
  test-template-db:
    description: 'Name of the template database for tests (only needed with pre-built: true)'
    required: false
    default: ''
  aws-dynamo-db-table:
    description: 'DynamoDB table name (only needed with pre-built: true)'
    required: false
    default: ''
  aws-dynamo-db-region:
    description: 'AWS region for DynamoDB (only needed with pre-built: true)'
    required: false
    default: ''
  aws-dynamo-db-endpoint:
    description: 'DynamoDB endpoint URL (only needed with pre-built: true)'
    required: false
    default: ''
  aws-dynamo-db-access-key-id:
    description: 'AWS access key ID for DynamoDB (only needed with pre-built: true)'
    required: false
    default: ''
  aws-dynamo-db-secret-access-key:
    description: 'AWS secret access key for DynamoDB (only needed with pre-built: true)'
    required: false
    default: ''

runs:
  using: "composite"
  steps:
    - name: Restore git cache
      if: inputs.pre-built != 'true'
      uses: actions/cache@v4
      with:
        path: .git
        key: ${{ github.repository }}-git-folder

    - name: Checkout code
      if: inputs.pre-built != 'true'
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ github.head_ref || github.ref_name }}

    - name: Setup node
      if: inputs.pre-built != 'true'
      uses: zerobias-org/devops/actions/setup-node@main

    - name: Configure git user
      shell: bash
      run: |
        git config user.name github-actions
        git config user.email github-actions@github.com

    - name: Install nx
      if: inputs.pre-built != 'true'
      shell: bash
      run: |
        npm install -g nx@22.4.2
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Install dependencies
      if: inputs.pre-built != 'true'
      shell: bash
      run: |
        cp .npmrc $HOME/.npmrc
        npm ci
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Install devops-tools
      shell: bash
      run: |
        cp .npmrc $HOME/.npmrc 2>/dev/null || true
        npm install -g @zerobias-org/devops-tools@latest
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Detect changed packages
      id: detect_changes
      shell: bash
      run: |
        # Detect packages with actual source changes (ignoring lock files)
        # Compare against origin/main to find all changes on this branch
        CHANGED_DIRS=$(npx detect-changes origin/main --hoisted)
        if [ -z "$CHANGED_DIRS" ]; then
          echo "No packages changed, skipping build/test"
          echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
        else
          echo "Changed packages (unsorted):"
          echo "$CHANGED_DIRS"
          # Convert newlines to spaces for safe use in for loops
          CHANGED_DIRS_INLINE=$(echo "$CHANGED_DIRS" | tr '\n' ' ')
          # Sort by dependency order for correct build sequence
          SORTED_DIRS=$(npx sort-by-deps $CHANGED_DIRS_INLINE)
          echo "Sorted by dependencies:"
          echo "$SORTED_DIRS"
          echo "CHANGED_DIRS=$SORTED_DIRS" >> $GITHUB_OUTPUT
          echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
        fi
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Build changed packages
      if: steps.detect_changes.outputs.HAS_CHANGES == 'true' && inputs.pre-built != 'true'
      shell: bash
      run: |
        # Function to get nx project name - tries project.json first, then directory basename
        get_nx_project_name() {
          local pkg_dir=$1
          if [ -f "$pkg_dir/project.json" ]; then
            jq -r ".name" "$pkg_dir/project.json"
          else
            basename "$pkg_dir"
          fi
        }

        # Build sequentially - nx handles its own parallelism and dependency ordering
        for pkg in ${{ steps.detect_changes.outputs.CHANGED_DIRS }}; do
          if [ -f "$pkg/package.json" ]; then
            PKG_NAME=$(jq -r ".name" "$pkg/package.json")
            NX_NAME=$(get_nx_project_name "$pkg")
            # Check if nx:build script exists in package.json
            if jq -e ".scripts[\"nx:build\"]" "$pkg/package.json" > /dev/null 2>&1; then
              echo "Building $PKG_NAME [nx project: $NX_NAME]"
              if ! timeout 300 nx nx:build "$NX_NAME"; then
                # Try with package.json name as fallback
                echo "Trying with package name $PKG_NAME"
                if ! timeout 300 nx nx:build "$PKG_NAME"; then
                  echo "::error::Build failed for $PKG_NAME"
                  exit 1
                fi
              fi
            else
              echo "Skipping $PKG_NAME - no nx:build target"
            fi
          fi
        done
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}
        JAVA_OPTS: "-Xms256m -Xmx1024m"

    - name: Test changed packages
      if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
      shell: bash
      run: |
        FAIL_FILE=$(mktemp)

        # Function to get nx project name - tries project.json first, then directory basename
        get_nx_project_name() {
          local pkg_dir=$1
          if [ -f "$pkg_dir/project.json" ]; then
            jq -r ".name" "$pkg_dir/project.json"
          else
            basename "$pkg_dir"
          fi
        }
        export -f get_nx_project_name

        # Function to run nx test with fallback to alternate project name
        run_nx_test() {
          local target=$1
          local pkg_dir=$2
          local fail_file=$3

          local pkg_name=$(jq -r ".name" "$pkg_dir/package.json")
          local nx_name=$(get_nx_project_name "$pkg_dir")

          echo "Testing $pkg_name ($target) [nx project: $nx_name]"

          # Try with nx project name first
          local output
          output=$(timeout 300 nx "$target" "$nx_name" 2>&1)
          local exit_code=$?

          if [ $exit_code -eq 0 ]; then
            echo "$output"
            return 0
          fi

          # Check if it failed with "Cannot find project" - try package.json name as fallback
          if echo "$output" | grep -q "Cannot find project"; then
            echo "Project '$nx_name' not found in nx, trying '$pkg_name'"
            if timeout 300 nx "$target" "$pkg_name"; then
              return 0
            else
              echo "::error::$target failed for $pkg_name"
              echo "$pkg_name:$target" >> "$fail_file"
              return 1
            fi
          else
            # Real test failure
            echo "$output"
            echo "::error::$target failed for $pkg_name"
            echo "$pkg_name:$target" >> "$fail_file"
            return 1
          fi
        }
        export -f run_nx_test

        echo "${{ steps.detect_changes.outputs.CHANGED_DIRS }}" | tr ' ' '\n' | \
        xargs -P4 -I{} bash -c '
          pkg="{}"
          if [ -f "$pkg/package.json" ]; then
            # Check if test:unit script exists in package.json
            if jq -e ".scripts[\"test:unit\"]" "$pkg/package.json" > /dev/null 2>&1; then
              run_nx_test "test:unit" "$pkg" "'"$FAIL_FILE"'"
            else
              echo "Skipping $(jq -r .name "$pkg/package.json") - no test:unit target"
            fi

            # Check if test:integration script exists in package.json
            if jq -e ".scripts[\"test:integration\"]" "$pkg/package.json" > /dev/null 2>&1; then
              run_nx_test "test:integration" "$pkg" "'"$FAIL_FILE"'"
            else
              echo "Skipping $(jq -r .name "$pkg/package.json") - no test:integration target"
            fi
          fi
        '
        if [ -s "$FAIL_FILE" ]; then
          echo "::error::Tests failed for: $(cat $FAIL_FILE | tr '\n' ', ')"
          rm -f "$FAIL_FILE"
          exit 1
        fi
        rm -f "$FAIL_FILE"
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}
        JAVA_OPTS: "-Xms256m -Xmx1024m"
        PGHOST: ${{ inputs.pg-host }}
        PGPORT: ${{ inputs.pg-port }}
        PGUSER: ${{ inputs.pg-user }}
        PGPASSWORD: ${{ inputs.pg-password }}
        PGDATABASE: ${{ inputs.pg-database }}
        TEST_TEMPLATE_DB: ${{ inputs.test-template-db }}
        AWS_DYNAMO_DB_TABLE: ${{ inputs.aws-dynamo-db-table }}
        AWS_DYNAMO_DB_REGION: ${{ inputs.aws-dynamo-db-region }}
        AWS_DYNAMO_DB_ENDPOINT: ${{ inputs.aws-dynamo-db-endpoint }}
        AWS_DYNAMO_DB_ACCESS_KEY_ID: ${{ inputs.aws-dynamo-db-access-key-id }}
        AWS_DYNAMO_DB_SECRET_ACCESS_KEY: ${{ inputs.aws-dynamo-db-secret-access-key }}

    - name: Slack Notification on failure
      uses: slackapi/slack-github-action@v2.1.1
      if: failure() && env.SLACK_DEVOPS_NOTIFICATIONS != ''
      with:
        webhook: ${{ env.SLACK_DEVOPS_NOTIFICATIONS }}
        webhook-type: incoming-webhook
        payload: |
          text: "${{ github.repository }} Pull Request Hoisted Failed"
          attachments:
            - color: "#ff0000"
              fallback: "Pull Request Hoisted Failed"
              title: ":fire: ${{ github.repository }} Pull Request Hoisted Failed"
              text: "Workflow run failed"
              footer: "<https://github.com/${{ github.repository }}|${{ github.repository }}> â€¢ <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View run>"
              mrkdwn_in:
                - text
                - footer
