name: 'Content PR Publish'
description: 'Handle the PR publish flow for zerobias-org content'
runs:
  using: "composite"
  steps:
    - name: Restore git cache
      uses: actions/cache@v4
      with:
        path: .git
        key: ${{ github.repository }}-git-folder

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ github.ref_name }}

    - name: Setup node
      uses: zerobias-org/devops/actions/setup-node@main

    - name: Setup Hugo
      uses: peaceiris/actions-hugo@v2
      with:
        hugo-version: '0.117.0'
        extended: true

    - name: Configure git user
      shell: bash
      run: |
        git config user.name github-actions
        git config user.email github-actions@github.com

    - name: Download artifact
      uses: actions/download-artifact@v4
      continue-on-error: true
      id: download
      with:
        name: ci-upload
        path: ~/ci-upload

    - name: 'Echo download path'
      shell: bash
      run: echo ${{steps.download.outputs.download-path}}

    - name: Install nx
      shell: bash
      run: |
        npm install -g nx@22.4.2
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Install dependencies
      shell: bash
      run: |
        cp .npmrc $HOME/.npmrc
        npm ci
        npm install -g @zerobias-org/devops-tools@latest
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Detect changed packages
      id: detect_changes
      shell: bash
      run: |
        # Detect packages with actual source changes (ignoring lock files)
        # Compare against origin/main to find all changes on this branch
        CHANGED_DIRS=$(npx detect-changes origin/main)
        if [ -z "$CHANGED_DIRS" ]; then
          echo "No packages changed, skipping build/publish"
          echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
        else
          echo "Changed packages:"
          echo "$CHANGED_DIRS"
          # Convert newlines to spaces for safe use in for loops
          CHANGED_DIRS_INLINE=$(echo "$CHANGED_DIRS" | tr '\n' ' ')
          echo "CHANGED_DIRS=$CHANGED_DIRS_INLINE" >> $GITHUB_OUTPUT
          echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
        fi
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Build changed packages
      if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
      shell: bash
      run: |
        echo "${{ steps.detect_changes.outputs.CHANGED_DIRS }}" | tr ' ' '\n' | \
        xargs -P4 -I{} bash -c '
          pkg="{}"
          if [ -f "$pkg/package.json" ]; then
            PROJECT_NAME=$(jq -r ".name" "$pkg/package.json")
            # Check if nx:build script exists in package.json
            if jq -e ".scripts[\"nx:build\"]" "$pkg/package.json" > /dev/null 2>&1; then
              echo "Building $PROJECT_NAME (from $pkg)"
              timeout 300 nx nx:build "$PROJECT_NAME" || echo "Warning: build failed for $PROJECT_NAME"
            else
              echo "Skipping $PROJECT_NAME - no nx:build target"
            fi
          fi
        '
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}
        JAVA_OPTS: "-Xms256m -Xmx1024m"

    - name: version
      id: version
      if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
      shell: bash
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}
      run: |
        # Get changed package names
        CHANGED_NAMES=$(npx get-changed-package-names origin/main)
        if [ -z "$CHANGED_NAMES" ]; then
          echo "No package names found, skipping version"
          echo "HAS_VERSION_CHANGES=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        echo "Versioning packages:"
        echo "$CHANGED_NAMES"

        # Build comma-separated list for lerna --force-publish
        FORCE_PUBLISH=$(echo "$CHANGED_NAMES" | tr '\n' ',' | sed 's/,$//')

        # Version with prerelease (rc) - separate from publish to avoid lerna publish bug
        # Allow current branch for pre-release versioning (overrides lerna.json allowBranch restriction)
        npx lerna version --force-publish="$FORCE_PUBLISH" --no-git-tag-version --no-push --conventional-commits --conventional-prerelease --preid rc --allow-branch "${{ github.ref_name }}" --yes

        echo "HAS_VERSION_CHANGES=true" >> $GITHUB_OUTPUT

    - name: Commit version changes
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      uses: EndBug/add-and-commit@v9
      with:
        add: '.'
        message: 'chore(release): bump version'
        default_author: github_actions
        push: true

    - name: publish
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      shell: bash
      env:
        NPM_TOKEN: ${{ env.WRITE_TOKEN }}
        READ_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}
      run: |
        # Initialize published packages file as empty array
        echo "[]" > /tmp/published-packages.json

        # Publish each changed package with rc tag and track what was published
        for pkg in ${{ steps.detect_changes.outputs.CHANGED_DIRS }}; do
          if [ -f "$pkg/package.json" ]; then
            echo "Publishing $pkg with rc tag"
            # Generate npm-shrinkwrap.json in isolation (outside workspace context)
            # Copy package to temp dir, install deps, create shrinkwrap, then publish
            if (
              TEMP_PUBLISH_DIR=$(mktemp -d)
              cp -r "$pkg"/* "$TEMP_PUBLISH_DIR/"
              cd "$TEMP_PUBLISH_DIR"
              # Install dependencies with read token (needs read:packages permission)
              NPM_TOKEN=$READ_TOKEN timeout 120 npm install --ignore-scripts
              npm shrinkwrap
              echo "Generated npm-shrinkwrap.json for $(jq -r .name package.json)"
              # Publish with write token
              NPM_TOKEN=$NPM_TOKEN timeout 120 npm publish --tag rc
            ); then
              # Add successfully published package to the list
              NAME=$(jq -r '.name' "$pkg/package.json")
              VERSION=$(jq -r '.version' "$pkg/package.json")
              LOCATION=$(realpath "$pkg")
              # Append to JSON array
              jq --arg name "$NAME" --arg version "$VERSION" --arg location "$LOCATION" \
                '. += [{"name": $name, "version": $version, "location": $location}]' \
                /tmp/published-packages.json > /tmp/published-packages.tmp.json
              mv /tmp/published-packages.tmp.json /tmp/published-packages.json
            else
              echo "Warning: Failed to publish $pkg"
            fi
          fi
        done

        echo "PUBLISHED_PACKAGES_FILE=/tmp/published-packages.json" >> $GITHUB_ENV
        echo "Captured published packages:"
        cat /tmp/published-packages.json

    - name: Apply dev tag
      shell: bash
      if: (github.ref_name == 'dev' || github.ref_name == 'qa') && steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      env:
        NPM_TOKEN: ${{ env.WRITE_TOKEN }}
      run: |
        if [ -n "$PUBLISHED_PACKAGES_FILE" ] && [ -f "$PUBLISHED_PACKAGES_FILE" ]; then
          for pkg in $(jq -r '.[].location' "$PUBLISHED_PACKAGES_FILE"); do
            NAME=$(jq -r '.name' "$pkg/package.json")
            VERSION=$(jq -r '.version' "$pkg/package.json")
            echo "Applying dev tag to $NAME@$VERSION"
            timeout 30 npm dist-tag add "$NAME@$VERSION" dev || echo "Warning: Failed to add dev tag"
          done
        else
          echo "No published packages file found, skipping dev tag"
        fi

    - name: Remove dev tag
      shell: bash
      if: (github.ref_name != 'dev' && github.ref_name != 'qa') && steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      env:
        NPM_TOKEN: ${{ env.WRITE_TOKEN }}
      run: |
        if [ -n "$PUBLISHED_PACKAGES_FILE" ] && [ -f "$PUBLISHED_PACKAGES_FILE" ]; then
          for pkg in $(jq -r '.[].location' "$PUBLISHED_PACKAGES_FILE"); do
            NAME=$(jq -r '.name' "$pkg/package.json")
            VERSION=$(jq -r '.version' "$pkg/package.json")
            echo "Removing dev tag from $NAME@$VERSION"
            timeout 30 npm dist-tag rm "$NAME@$VERSION" dev || echo 'dev tag not present'
          done
        else
          echo "No published packages file found, skipping dev tag removal"
        fi


    - name: Apply qa tag
      shell: bash
      if: github.ref_name == 'qa' && steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      env:
        NPM_TOKEN: ${{ env.WRITE_TOKEN }}
      run: |
        if [ -n "$PUBLISHED_PACKAGES_FILE" ] && [ -f "$PUBLISHED_PACKAGES_FILE" ]; then
          for pkg in $(jq -r '.[].location' "$PUBLISHED_PACKAGES_FILE"); do
            NAME=$(jq -r '.name' "$pkg/package.json")
            VERSION=$(jq -r '.version' "$pkg/package.json")
            echo "Applying qa tag to $NAME@$VERSION"
            timeout 30 npm dist-tag add "$NAME@$VERSION" qa || echo "Warning: Failed to add qa tag"
          done
        else
          echo "No published packages file found, skipping qa tag"
        fi        

    - name: Remove qa tag
      shell: bash
      if: github.ref_name != 'qa' && steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      env:
        NPM_TOKEN: ${{ env.WRITE_TOKEN }}
      run: |
        if [ -n "$PUBLISHED_PACKAGES_FILE" ] && [ -f "$PUBLISHED_PACKAGES_FILE" ]; then
          for pkg in $(jq -r '.[].location' "$PUBLISHED_PACKAGES_FILE"); do
            NAME=$(jq -r '.name' "$pkg/package.json")
            VERSION=$(jq -r '.version' "$pkg/package.json")
            echo "Removing qa tag from $NAME@$VERSION"
            timeout 30 npm dist-tag rm "$NAME@$VERSION" qa || echo 'qa tag not present'
          done
        else
          echo "No published packages file found, skipping qa tag removal"
        fi

    - name: Add skip-dataloader tag
      shell: bash
      if: contains(steps.pr.outputs.pr_labels, 'skip-dataloader') && steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      env:
        NPM_TOKEN: ${{ env.WRITE_TOKEN }}
      run: |
        if [ -n "$PUBLISHED_PACKAGES_FILE" ] && [ -f "$PUBLISHED_PACKAGES_FILE" ]; then
          for pkg in $(jq -r '.[].location' "$PUBLISHED_PACKAGES_FILE"); do
            NAME=$(jq -r '.name' "$pkg/package.json")
            VERSION=$(jq -r '.version' "$pkg/package.json")
            echo "Applying skip-dataloader tag to $NAME@$VERSION"
            timeout 30 npm dist-tag add "$NAME@$VERSION" skip-dataloader || echo "Warning: Failed to add skip-dataloader tag"
          done
        else
          echo "No published packages file found, skipping skip-dataloader tag"
        fi

    - name: Remove skip-dataloader tag
      shell: bash
      if: ${{ ! contains(steps.pr.outputs.pr_labels, 'skip-dataloader') }} && steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      env:
        NPM_TOKEN: ${{ env.WRITE_TOKEN }}
      run: |
        if [ -n "$PUBLISHED_PACKAGES_FILE" ] && [ -f "$PUBLISHED_PACKAGES_FILE" ]; then
          for pkg in $(jq -r '.[].location' "$PUBLISHED_PACKAGES_FILE"); do
            NAME=$(jq -r '.name' "$pkg/package.json")
            VERSION=$(jq -r '.version' "$pkg/package.json")
            echo "Removing skip-dataloader tag from $NAME@$VERSION"
            timeout 30 npm dist-tag rm "$NAME@$VERSION" skip-dataloader || echo 'skip-dataloader tag not present'
          done
        else
          echo "No published packages file found, skipping skip-dataloader tag removal"
        fi

    # Run only if just a tag workflow not a publish
    - name: Post Pre Release
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      shell: bash
      run: |
        if [ -x scripts/postprerelease.sh ]
        then
          bash scripts/postprerelease.sh
        fi

    - name: Post PR Publish
      if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
      shell: bash
      run: |
        if [ -x scripts/postprpublish.sh ]
        then
          npm config list
          bash scripts/postprpublish.sh
        fi
      env:
        UPLOAD_FOLDER_PATH: ${{steps.download.outputs.download-path}}

    - name: Release Announcement
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      uses: zerobias-org/devops/nx-actions/release-announcement@main
      with:
        packages-file: ${{ env.PUBLISHED_PACKAGES_FILE }}
        branch: ${{ github.ref_name }}
        dist-tag: ${{ github.ref_name }}
        aws-role-arn: arn:aws:iam::961260934100:role/github-actions-publishing-role


    - name: Slack Notification on failure
      uses: slackapi/slack-github-action@v2.1.1
      if: failure() && env.SLACK_DEVOPS_NOTIFICATIONS != ''
      with:
        webhook: ${{ env.SLACK_DEVOPS_NOTIFICATIONS }}
        webhook-type: incoming-webhook
        payload: |
          text: "${{ github.repository }} PR Publish Failed"
          attachments:
            - color: "#ff0000"
              fallback: "PR Publish Failed"
              title: ":fire: ${{ github.repository }} PR Publish Failed"
              text: "Workflow run failed"
              footer: "<https://github.com/${{ github.repository }}|${{ github.repository }}> â€¢ <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View run>"
              mrkdwn_in:
                - text
                - footer
