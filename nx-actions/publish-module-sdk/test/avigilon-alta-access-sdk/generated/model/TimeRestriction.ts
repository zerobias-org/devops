/* eslint-disable */
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
import { EnumValue, IllegalArgumentError } from '@zerobias-org/types-core-js';
import { ObjectSerializer, RequestFile } from './index.js';

export class TimeRestriction {
  /**
  * Start time for access
  */
  'startTime'?: Date;
  /**
  * End time for access
  */
  'endTime'?: Date;
  /**
  * Days of the week when access is allowed
  */
  'daysOfWeek'?: Array<TimeRestriction.DaysOfWeekEnumDef>;
  /**
  * Start date for the time restriction
  */
  'validFrom'?: Date;
  /**
  * End date for the time restriction
  */
  'validUntil'?: Date;

  static readonly discriminator: string | undefined = undefined;

  static attributeTypeMap: ReadonlyArray<{name: string, baseName: string, type: string, format: string}> = [
    {
      "name": "startTime",
      "baseName": "startTime",
      // false
      // Date
      // Date
      "type": "Date",
      "format": "date-time"
    },
    {
      "name": "endTime",
      "baseName": "endTime",
      // false
      // Date
      // Date
      "type": "Date",
      "format": "date-time"
    },
    {
      "name": "daysOfWeek",
      "baseName": "daysOfWeek",
      // true
      // Array&lt;TimeRestriction.DaysOfWeekEnum&gt;
      // Array&lt;TimeRestriction.DaysOfWeekEnumDef&gt;
      "type": "Array<TimeRestriction.DaysOfWeekEnum>",
      "format": ""
    },
    {
      "name": "validFrom",
      "baseName": "validFrom",
      // false
      // Date
      // Date
      "type": "Date",
      "format": "date"
    },
    {
      "name": "validUntil",
      "baseName": "validUntil",
      // false
      // Date
      // Date
      "type": "Date",
      "format": "date"
    }  ];

  static getAttributeTypeMap() {
    return TimeRestriction.attributeTypeMap;
  }

  static newInstance(obj: any): TimeRestriction {
    return ObjectSerializer.deserialize(obj, 'TimeRestriction');
  }

  constructor(startTime?: Date, endTime?: Date, daysOfWeek?: Array<TimeRestriction.DaysOfWeekEnumDef>, validFrom?: Date, validUntil?: Date) {
    this.startTime = startTime;
    this.endTime = endTime;
    this.daysOfWeek = daysOfWeek;
    this.validFrom = validFrom;
    this.validUntil = validUntil;
  }
}

export namespace TimeRestriction {
  export const DaysOfWeekEnum = {
    /**  */
    Monday: EnumValue.instance('TimeRestriction.DaysOfWeekEnum', 'Monday', 'monday'),
    /**  */
    Tuesday: EnumValue.instance('TimeRestriction.DaysOfWeekEnum', 'Tuesday', 'tuesday'),
    /**  */
    Wednesday: EnumValue.instance('TimeRestriction.DaysOfWeekEnum', 'Wednesday', 'wednesday'),
    /**  */
    Thursday: EnumValue.instance('TimeRestriction.DaysOfWeekEnum', 'Thursday', 'thursday'),
    /**  */
    Friday: EnumValue.instance('TimeRestriction.DaysOfWeekEnum', 'Friday', 'friday'),
    /**  */
    Saturday: EnumValue.instance('TimeRestriction.DaysOfWeekEnum', 'Saturday', 'saturday'),
    /**  */
    Sunday: EnumValue.instance('TimeRestriction.DaysOfWeekEnum', 'Sunday', 'sunday'),

    from(val: string | number): EnumValue {
      if (DaysOfWeekEnum[val]) {
        return DaysOfWeekEnum[val];
      }
      const byValue = DaysOfWeekEnum.values.find((v) => v.value === val);
      if (byValue) {
        return byValue;
      }
      throw new IllegalArgumentError(`${val} is not a valid DaysOfWeekEnum`);
    },

    get values(): EnumValue[] {
      return Object
        .keys(DaysOfWeekEnum)
        .filter((k) => k !== 'values' && k !== 'from')
        .map((t) => DaysOfWeekEnum[t]);
    }
  } as const;

  export type DaysOfWeekEnumDef = typeof DaysOfWeekEnum[keyof typeof DaysOfWeekEnum];
}
