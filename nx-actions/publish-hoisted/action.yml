name: 'Publish Hoisted'
description: 'Runs to publish a zerobias-org or zerobias-com hoisted mono repo'

inputs:
  publishToken:
    description: 'NPM token for publishing packages'
    required: true
  pre-built:
    description: 'Set to true if build was already run externally, skips build step'
    required: false
    default: 'false'

outputs:
  has_version_changes:
    description: 'Whether any packages were versioned and published'
    value: ${{ steps.set_outputs.outputs.has_version_changes }}
  published_packages:
    description: 'JSON array of published packages with name, version, location'
    value: ${{ steps.set_outputs.outputs.published_packages }}
  changed_dirs:
    description: 'Space-separated list of changed package directories'
    value: ${{ steps.detect_changes.outputs.CHANGED_DIRS }}

runs:
  using: 'composite'
  steps:
    - name: Restore git cache
      if: inputs.pre-built != 'true'
      uses: actions/cache@v4
      with:
        path: .git
        key: ${{ github.repository }}-git-folder

    - name: Checkout code
      if: inputs.pre-built != 'true'
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node
      if: inputs.pre-built != 'true'
      uses: zerobias-org/devops/nx-actions/setup-node@main

    - name: configure git user
      shell: bash
      run: |
        git config --global user.email "ci@neverfail.com"
        git config --global user.name "@$GITHUB_ACTOR"

    - name: Install nx
      if: inputs.pre-built != 'true'
      shell: bash
      run: |
        npm install -g nx@22.4.2
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Install dependencies
      if: inputs.pre-built != 'true'
      shell: bash
      run: |
        cp .npmrc $HOME/.npmrc
        npm ci
        npm install -g @zerobias-org/devops-tools@latest
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Detect changed packages
      id: detect_changes
      shell: bash
      run: |
        # Get last published tag
        LAST_PUBLISH_TAG=$(git describe --tags --abbrev=0 --match="*" 2>/dev/null || echo "HEAD~1")
        echo "Using base ref: $LAST_PUBLISH_TAG"

        # Detect packages with actual source changes (ignoring lock files)
        CHANGED_DIRS=$(npx detect-changes "$LAST_PUBLISH_TAG" --hoisted)
        if [ -z "$CHANGED_DIRS" ]; then
          echo "No packages changed, skipping build/publish"
          echo "HAS_CHANGES=false" >> $GITHUB_OUTPUT
        else
          echo "Changed packages (unsorted):"
          echo "$CHANGED_DIRS"
          # Convert newlines to spaces for safe use in for loops
          CHANGED_DIRS_INLINE=$(echo "$CHANGED_DIRS" | tr '\n' ' ')
          # Sort by dependency order for correct build/publish sequence
          SORTED_DIRS=$(npx sort-by-deps $CHANGED_DIRS_INLINE)
          echo "Sorted by dependencies:"
          echo "$SORTED_DIRS"
          echo "CHANGED_DIRS=$SORTED_DIRS" >> $GITHUB_OUTPUT
          echo "HAS_CHANGES=true" >> $GITHUB_OUTPUT
          echo "BASE_REF=$LAST_PUBLISH_TAG" >> $GITHUB_OUTPUT
        fi
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: Build changed packages
      if: steps.detect_changes.outputs.HAS_CHANGES == 'true' && inputs.pre-built != 'true'
      shell: bash
      run: |
        # Build sequentially - nx handles its own parallelism and dependency ordering
        for pkg in ${{ steps.detect_changes.outputs.CHANGED_DIRS }}; do
          if [ -f "$pkg/package.json" ]; then
            PROJECT_NAME=$(jq -r ".name" "$pkg/package.json")
            # Check if nx:build script exists in package.json
            if jq -e ".scripts[\"nx:build\"]" "$pkg/package.json" > /dev/null 2>&1; then
              echo "Building $PROJECT_NAME (from $pkg)"
              if ! timeout 300 nx nx:build "$PROJECT_NAME"; then
                echo "::error::Build failed for $PROJECT_NAME"
                exit 1
              fi
            else
              echo "Skipping $PROJECT_NAME - no nx:build target"
            fi
          fi
        done
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}
        JAVA_OPTS: "-Xms256m -Xmx1024m"

    - name: version
      id: version
      if: steps.detect_changes.outputs.HAS_CHANGES == 'true'
      shell: bash
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}
      run: |
        echo `git status`

        # Get changed package names for filtered lerna operations
        CHANGED_NAMES=$(npx get-changed-package-names "${{ steps.detect_changes.outputs.BASE_REF }}" --hoisted)
        if [ -z "$CHANGED_NAMES" ]; then
          echo "No package names found, skipping version"
          echo "HAS_VERSION_CHANGES=false" >> $GITHUB_OUTPUT
          exit 0
        fi
        echo "Versioning packages:"
        echo "$CHANGED_NAMES"

        # Build comma-separated list for lerna --force-publish
        FORCE_PUBLISH=$(echo "$CHANGED_NAMES" | tr '\n' ',' | sed 's/,$//')
        echo "Force publish list: $FORCE_PUBLISH"

        # Use patch bump for changed packages
        npx lerna version patch --force-publish="$FORCE_PUBLISH" --no-git-tag-version --no-push --yes

        # Detect ALL packages that lerna bumped (including dependency cascade)
        # These are packages with modified package.json files
        BUMPED_DIRS=$(git diff --name-only | grep 'package\.json$' | grep -v '^package\.json$' | grep -v 'package-lock\.json' | xargs -I {} dirname {} | sort -u | tr '\n' ' ')
        if [ -n "$BUMPED_DIRS" ]; then
          # Sort bumped packages by dependency order
          SORTED_BUMPED=$(npx sort-by-deps $BUMPED_DIRS)
          echo "Packages bumped by lerna (including dependents):"
          echo "$SORTED_BUMPED"
          echo "BUMPED_DIRS=$SORTED_BUMPED" >> $GITHUB_OUTPUT
        else
          echo "BUMPED_DIRS=${{ steps.detect_changes.outputs.CHANGED_DIRS }}" >> $GITHUB_OUTPUT
        fi

        echo "HAS_VERSION_CHANGES=true" >> $GITHUB_OUTPUT

    - name: Commit version changes
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      uses: EndBug/add-and-commit@v9
      with:
        add: '.'
        message: 'chore(release): bump version'
        default_author: github_actions
        push: true

    - name: Save package.json state before prepublish
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      shell: bash
      run: |
        echo "Saving package.json files before prepublish modifications..."
        mkdir -p /tmp/package-json-backup
        # Use BUMPED_DIRS to include all packages that will be published (including dependents)
        for pkg in ${{ steps.version.outputs.BUMPED_DIRS }}; do
          if [ -f "$pkg/package.json" ]; then
            mkdir -p "/tmp/package-json-backup/$pkg"
            cp "$pkg/package.json" "/tmp/package-json-backup/$pkg/package.json"
            echo "Backed up $pkg/package.json"
          fi
        done

    - name: Prepare standalone packages
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      shell: bash
      run: |
        # Use BUMPED_DIRS to prepare all packages that will be published
        for pkg in ${{ steps.version.outputs.BUMPED_DIRS }}; do
          if [ -f "$pkg/package.json" ]; then
            PROJECT_NAME=$(jq -r ".name" "$pkg/package.json")
            echo "Preparing $PROJECT_NAME (from $pkg) for standalone publish"
            pushd "$pkg" > /dev/null
            if ! timeout 120 npx prepublish-standalone; then
              echo "::error::Prepublish failed for $PROJECT_NAME"
              popd > /dev/null
              exit 1
            fi
            popd > /dev/null
          fi
        done
      env:
        NPM_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}

    - name: publish
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      shell: bash
      env:
        PUBLISH_TOKEN: ${{ inputs.publishToken }}
        READ_TOKEN: ${{ env.READ_TOKEN }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}
      run: |
        # Create temp directory for individual publish results
        PUBLISH_RESULTS_DIR=$(mktemp -d)
        FAIL_FILE=$(mktemp)
        REPO_ROOT=$(pwd)
        export PUBLISH_RESULTS_DIR
        export FAIL_FILE
        export PUBLISH_TOKEN
        export READ_TOKEN

        # Publish ALL bumped packages in dependency order (includes dependents from lerna cascade)
        for pkg in ${{ steps.version.outputs.BUMPED_DIRS }}; do
          if [ -f "$pkg/package.json" ]; then
            PROJECT_NAME=$(jq -r ".name" "$pkg/package.json")
            PROJECT_VERSION=$(jq -r ".version" "$pkg/package.json")

            # Check if package has custom nx:publish script
            if jq -e ".scripts[\"nx:publish\"]" "$pkg/package.json" > /dev/null 2>&1; then
              echo "Publishing $PROJECT_NAME using custom nx:publish script"
              pushd "$pkg" > /dev/null
              # Copy .npmrc for registry auth
              cp "$HOME/.npmrc" .npmrc 2>/dev/null || true
              # Run custom publish script with write token
              if NPM_TOKEN=$PUBLISH_TOKEN timeout 120 nx nx:publish "$PROJECT_NAME"; then
                # Write published package info
                HASH=$(echo "$pkg" | md5sum | cut -d" " -f1)
                echo "{\"name\": \"$PROJECT_NAME\", \"version\": \"$PROJECT_VERSION\", \"location\": \"$(realpath .)\"}" > "$PUBLISH_RESULTS_DIR/$HASH.json"

                # Create tag
                TAG_NAME="${PROJECT_NAME}@${PROJECT_VERSION}"
                echo "Creating tag: $TAG_NAME"
                git -C "$REPO_ROOT" tag -f "$TAG_NAME" -m "Published $PROJECT_NAME version $PROJECT_VERSION"
                timeout 60 git -C "$REPO_ROOT" push origin "$TAG_NAME" --force || echo "Warning: Failed to push tag $TAG_NAME"
              else
                echo "::error::Failed to publish $pkg"
                echo "$pkg" >> "$FAIL_FILE"
              fi
              popd > /dev/null
            else
              # Default publish behavior - use publish-hoisted script
              echo "Publishing $pkg with latest tag"
              pushd "$pkg" > /dev/null
              if PUBLISH_OUTPUT=$(NPM_TOKEN=$PUBLISH_TOKEN npx publish-hoisted --tag latest 2>&1); then
                # Extract JSON from output (grep for marker prefix)
                PUBLISH_JSON=$(echo "$PUBLISH_OUTPUT" | grep "^PUBLISH_RESULT:" | sed 's/^PUBLISH_RESULT://')
                HASH=$(echo "$pkg" | md5sum | cut -d" " -f1)
                echo "$PUBLISH_JSON" > "$PUBLISH_RESULTS_DIR/$HASH.json"

                # Create tag immediately after successful publish
                TAG_NAME="${PROJECT_NAME}@${PROJECT_VERSION}"
                echo "Creating tag: $TAG_NAME"
                git -C "$REPO_ROOT" tag -f "$TAG_NAME" -m "Published $PROJECT_NAME version $PROJECT_VERSION"
                timeout 60 git -C "$REPO_ROOT" push origin "$TAG_NAME" --force || echo "Warning: Failed to push tag $TAG_NAME"
              else
                echo "$PUBLISH_OUTPUT"
                echo "::error::Failed to publish $pkg"
                echo "$pkg" >> "$FAIL_FILE"
              fi
              popd > /dev/null
            fi
          fi
        done

        # Merge all individual results into final JSON array
        echo "[]" > /tmp/published-packages.json
        for result_file in "$PUBLISH_RESULTS_DIR"/*.json; do
          if [ -f "$result_file" ]; then
            jq --slurpfile pkg "$result_file" '. += $pkg' /tmp/published-packages.json > /tmp/published-packages.tmp.json
            mv /tmp/published-packages.tmp.json /tmp/published-packages.json
          fi
        done
        rm -rf "$PUBLISH_RESULTS_DIR"

        echo "PUBLISHED_PACKAGES_FILE=/tmp/published-packages.json" >> $GITHUB_ENV
        echo "HAS_VERSION_CHANGES=true" >> $GITHUB_ENV
        echo "Captured published packages:"
        cat /tmp/published-packages.json

        # Check for publish failures
        if [ -s "$FAIL_FILE" ]; then
          echo "::error::Publish failed for: $(cat $FAIL_FILE | tr '\n' ', ')"
          rm -f "$FAIL_FILE"
          exit 1
        fi
        rm -f "$FAIL_FILE"

        echo "packages published"

    - name: Restore package.json state after publish
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      shell: bash
      run: |
        echo "Restoring package.json files to pre-prepublish state..."
        # Restore all bumped packages (same set that was backed up)
        for pkg in ${{ steps.version.outputs.BUMPED_DIRS }}; do
          if [ -f "/tmp/package-json-backup/$pkg/package.json" ]; then
            cp "/tmp/package-json-backup/$pkg/package.json" "$pkg/package.json"
            echo "Restored $pkg/package.json"
          fi
        done

    - name: Set action outputs
      id: set_outputs
      shell: bash
      run: |
        echo "has_version_changes=${{ steps.version.outputs.HAS_VERSION_CHANGES || 'false' }}" >> $GITHUB_OUTPUT
        if [ -n "${{ env.PUBLISHED_PACKAGES_FILE }}" ] && [ -f "${{ env.PUBLISHED_PACKAGES_FILE }}" ]; then
          # Read packages file and output as single-line JSON
          PACKAGES=$(cat "${{ env.PUBLISHED_PACKAGES_FILE }}" | jq -c '.')
          echo "published_packages=$PACKAGES" >> $GITHUB_OUTPUT
        else
          echo "published_packages=[]" >> $GITHUB_OUTPUT
        fi

    - name: post publish
      if: steps.version.outputs.HAS_VERSION_CHANGES == 'true'
      shell: bash
      env:
        NPM_TOKEN: ${{ inputs.publishToken }}
        ZB_TOKEN: ${{ env.ZB_TOKEN }}
        READ_TOKEN: ${{ env.READ_TOKEN }}
        PUBLISHED_PACKAGES_FILE: ${{ env.PUBLISHED_PACKAGES_FILE }}
      run: |
        if [ -x scripts/postpublish.sh ]; then
          scripts/postpublish.sh
        fi

    - name: Release Announcement
      if: ${{ inputs.skip-publish-announcement != 'true' && steps.version.outputs.HAS_VERSION_CHANGES == 'true' }}
      uses: zerobias-org/devops/nx-actions/release-announcement@main
      with:
        packages-file: ${{ env.PUBLISHED_PACKAGES_FILE }}
        branch: ${{ github.ref_name }}
        dist-tag: latest
        aws-role-arn: arn:aws:iam::961260934100:role/github-actions-publishing-role
